---

---

<section
  id="tree-3d"
  class="w-[95vw] max-w-[400px] aspect-square mx-auto cursor-grab active:cursor-grabbing -mt-[10%] z-5 pointer-events-auto overflow-visible "
>
</section>
<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { gsap } from "gsap";
  import { loadEnvironment, setRenderer } from "../../utils/gainMap";
  gsap.ticker.lagSmoothing(0);

  // Set up the scene, camera
  const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
  const scene = new THREE.Scene();
  const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
  setRenderer(renderer);
  // Orbit Controls (Disable Zoom)
  const controls = new OrbitControls(camera, renderer.domElement);

  controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
  controls.dampingFactor = 0.05;
  controls.enablePan = false;
  //   controls.minDistance = 100;
  //   controls.maxDistance = 500;
  controls.enableZoom = false; // Disable zoom
  controls.minPolarAngle = Math.PI / 2; // Lock vertical rotation
  controls.maxPolarAngle = Math.PI / 2; // Allow looking slightly downward
  controls.target.set(0, 12, 0); // This is where your model's center is
  controls.update(); // Update the controls to reflect the new target position
  // Select the container
  // controls.mouseButtons = {
  //   LEFT: THREE.MOUSE.ROTATE, // Left-click: Rotate
  //   MIDDLE: THREE.MOUSE.DOLLY, // Middle-click: Zoom
  //   RIGHT: THREE.MOUSE.NONE, // Disable right-click panning
  // };
  const container = document.getElementById("tree-3d");
  if (!container) {
    console.error("Container #tree-3d not found!");
  } else {
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    renderer.setSize(containerWidth, containerHeight);
    renderer.setClearColor(0xffffff, 0);
    renderer.setAnimationLoop(animate);
    container.appendChild(renderer.domElement);
  }

  let tree: THREE.Object3D | null = null; // Global reference to the 3D model

  // const textureLoader = new THREE.TextureLoader();
  // textureLoader.load("/courtyard512.webp", (texture) => {
  //   texture.mapping = THREE.EquirectangularReflectionMapping;
  //   scene.background = null;
  //   scene.environment = texture;
  // });
  loadEnvironment().then((env) => {
    scene.environment = env;
    scene.background = null;
  });
  // Load 3D Model
  const loader = new GLTFLoader();
  loader.load(
    "/realTree.glb",
    function (gltf) {
      tree = gltf.scene;

      // Rotate continuously
      gsap.to(tree.rotation, {
        y: "+=6.28",
        repeat: -1,
        duration: 30,
        ease: "none",
      });
 // Increase the saturation for all materials of the real tree
 tree.traverse((child) => {
      if (child instanceof THREE.Mesh) {  // Check if child is a mesh
        const material = child.material;
        if (material.map) {
          const color = new THREE.Color();
          const saturationFactor = 2; // Example: increase saturation by 50%
          color.setRGB(material.color.r * saturationFactor, material.color.g * saturationFactor, material.color.b * saturationFactor);
          material.color.set(color);
        }
      }
    });
      // Resize model
      // tree.scale.set(1.3, 1.3, 1.3);
 tree.scale.set(2.7, 2.7, 2.7);
      // Add model to scene
      scene.add(tree);
    },
    undefined,
    function (error) {
      console.error(error);
    }
  );
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambientLight);
  // // //   // Add Lights
  // const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  // scene.add(ambientLight);

  // const directionalLight = new THREE.DirectionalLight("#ffffff", 2.5);
  // directionalLight.position.set(-4, 6.5, 2.5);
  // scene.add(directionalLight);

  // // Shadows
  // directionalLight.castShadow = true;
  // directionalLight.shadow.camera.far = 15;
  // directionalLight.shadow.normalBias = 0.027;
  // directionalLight.shadow.bias = -0.004;
  // directionalLight.shadow.mapSize.set(256, 256);

  camera.position.set(0, 0, 12);

  // Animate the scene
  function animate() {
    controls.update();
    renderer.render(scene, camera);
  }
</script>
